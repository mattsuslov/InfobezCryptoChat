*Индивидуальное задание*

#ВЗАИМОДЕЙСТВИЕ КЛИЕНТ-СЕРВЕР
Я реализовал протокол Диффи-Хелмана - далее DH. В рамках него две стороны получают *общий секретный ключ*, который можно использовать с алгоритмами симметричного шифрования. Для демонстрации я использоую алгоритм AES (проверка целостности сообщения уже включена в него).

Код написан с использованием концепции кодеков, что дает возможность легко заменять/отключать алгоритмы шифрования.

При шифровании ключа используется хеширование HKDF поверх DH‑секрета для того чтобы:
1) Равномерность/псевдослучайность. DH‑секрет имеет структуру и не распределён идеально равномерно в байтовом виде. HKDF делает из него криптографически равномерный ключ. Дает устойчивость к статистическим методам криптоанализа.
2) Дополнительная полезная нагрузка хеша (info = "…-CHAT" + pk_client + pk_server)позволяет:
    - "привязать" ключ к протоколу
    - получать ключи для разных целей. Например, можно сформировать подгруппу пользователей, если мы делаем чат на основе данного протокола.
    - из одного секрета можно получать множество ключей. Например, для отправки/приема. Это можно использовать в аналитике, считая метрики по этим ключам.
3) Генерируем nonce - случайная битовая последовательность на каждое сообщение. Без nonce один и тот-же открытый текст дает одинаковый шифротектс. Надо обратить внимание, что:
    - AES - это поточный алгоритм шифрования. Он использует генератор и выбирает seed с помощью nonce. Зная пару (nonce, ключ) можно воспроизвести случайную последовательность. Следовательно можно не только изменить, но и подделать сообщения.
    - nonce передается открыто. Важно, чтобы он не повторялся, иначе AES-GCM ломается

Почему именно HKDF, а не “просто SHA‑256”:
HKDF — стандартный, формально проанализированный KDF (RFC 5869) с этапами extract/expand. Он лучше приспособлен для “выжимки” энтропии и выдачи ключей нужной длины и количества, чем одноразовый хеш.

Доп. возможности HKDF, которые не используются:
1) Сейчас salt=None (по RFC это эквивалентно нулевому salt). Это публичная информация для хеширования, которая привязать ключ к сессии/протоколу/конкретному событию. info применяется на этапе HKDF-Expand, а salt применяется раньше на этапе HKDF-Extract при вытягивании энтропии.

#ВЗАИМОДЕЙСТВИЕ КЛИЕНТ-КЛИЕНТ
Для передачи сообщений друг другу у клиентов есть возможность *сквозного* шифрования. 

Реализация:
1) При подключении клиент отправляет HELLO на сервер в незашифрованном виде, куда кладет свой открытй ключ.
2) Другие клиенты, которые видят этот HELLO и поддерживают протокол сквозного шифрования, запоминают публичный ключ клиента
3) Все клиенты, кто поддерживает протокол сквозного шифр., отправляют REPLY со своими публичными ключами.
4) Таким образом все получают публичные ключи друг друга, а значит имеют возможность сгенерировать общий секретный ключ.
5) При отправке клиентом выбирается множество других клиентов, кому он хочет отправить сообщения. Для каждого клиента из этого множетсва генерируется свой секретный ключ (DH-секрет + HRDF хеш). Клиент шифрует сообщение алгоритмом AESGCM и отправляет его на сервер. Зашифрованное сообщение доступно всем пользователям, но расшифровать его может только получатель, так как секретный ключ уникален для пары пользователей.

Итого:
Я подготовил cli приложение для клиента, которое подключается к серверу и организует общением между клиентами по описанному выше протоколу. В приложении доступны команды:

/personal <username> <msg> - отправка сообщения одному пользователю через сквозное шифрование
/group <username1>,<username2> <ms> - отправка греппе пользователей через сквозное шифрование
/announce - заново провести процесс рукопожатия, чтобы обновить все публичные ключи пользователей
/all <msg> - отправить всем пользователям зашифрованное сообщение (сервер не сможет его прочитать)
<msg> - отправить открытое сообщение без шифрования (все пользователи и сервер его прочитают)
